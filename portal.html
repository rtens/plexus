<!DOCTYPE html>
<html>

<body style="background-color: #111">

  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>

  <canvas id="myCanvas" width="800" height="600">
    Sorry, your browser does not support canvas.
  </canvas>

  <script>

    ////// Shapes ////////
    const sphere = p => len(p) - 1

    const box = b => p => {
      const q = add(p.map(Math.abs), neg(b))
      return len(q.map(n => Math.max(n, 0))) + Math.min(Math.max(...q, 0), 0);
    }

    const torus = ([tx, ty]) => ([x, y, z]) => {
      const q = [len([x, z]) - tx, y]
      return len(q) - ty
    }

    ////// Materials ////////
    const cyan = () => [0, 1, 1]
    const magenta = () => [1, 0, 1]
    const yellow = () => [1, 1, 0]
    const red = () => [1, 0, 0]
    const green = () => [0, 1, 0]
    const blue = () => [0, 0, 1]

    ////// Construction ////////
    const obj = (sdf, mat) => p => [sdf(p), mat(p)]

    const union = (...objs) => p =>
      objs.reduce((a, c) => !a || c(p)[0] < a[0] ? c(p) : a, null)

    const sunion = (k, o1, o2) => p => {
      const [d1, m1] = o1(p)
      const [d2, m2] = o2(p)
      const h = clamp(.5 + .5 * (d2 - d1) / k, 0, 1)
      return [
        fade(d2, d1, h) - k * h * (1 - h),
        mix([m1, m2], [h, 1 - h])
      ]
    }

    const move = v => f => p => f(add(p, neg(v)))

    const rot = (u, r) => f => p => f(mmul(rot3(u, r), p))

    const scale = s => f => p => (([d, m]) => [d * s, m])(f(mul(p, 1 / s)))

    const round = r => f => p => (([d, m]) => [d - r, m])(f(p))

    const $ = (i, ...p) => p.reduce((a, c) => c(a), i)

    ////// Rendering ////////
    let scene = sunion(.1,
      sunion(.3,
        $(obj(box([1, .6, .7]), magenta),
          round(.3),
          rot([1, 1, 0], .8),
          move([-.5, -.5, -6])),
        $(obj(sphere, cyan),
          scale(1.2),
          move([.3, .8, -6]))),
      $(obj(torus([1.2, .3]), yellow),
        rot([1, 0, 0], -.5),
        move([0.5, -.5, -6])))

    class Camera {
      constructor() {
        this.focal = 1
        this.maxdist = 100
        this.dimming = .9
      }

      async render(scene, canvas) {
        const [rx, ry] = canvas.resolution

        const chunk = 1000
        for (let i = 0; i < rx * ry; i += chunk) {
          const c = i
          await new Promise(resolve => setTimeout(() => {
            for (let j = c; j < c + chunk; j++) {
              const x = j % rx
              const y = Math.floor(j / rx)

              const colors = this.rays(x, y, rx, ry)
                .map(ray => this.fragment(scene, ray))
              canvas.paint(x, y, mix(colors))
              resolve()
            }
          }))
        }
      }

      rays(x, y, rx, ry) {
        const subs = [[.87, .5], [-.87, .5], [0, -1]]
        return subs.map(([dx, dy]) => norm([
          + ((x + .5 + dx / 4) / rx - .5),
          - ((y + .5 + dy / 4) / ry - .5) * (ry / rx),
          -this.focal
        ]))
      }

      fragment(scene, ray) {
        let dist = 0

        while (dist < this.maxdist) {
          const point = mul(ray, dist)
          const [d, m] = scene(point)
          dist += d

          if (d < 0.001 * dist) {
            return this.shade(scene, m, point, ray)
          }
        }

        return [0, 0, 0]
      }

      shade(scene, m, point, ray) {
        const n = this.normal(scene, point)
        const f = (dot(ray, neg(n)) - 1) * this.dimming + 1
        return mix([m, [0, 0, 0]], [f, 1 - f])
        return mul(m, f)
      }

      normal(scene, point) {
        const e = 0.0001
        const de = ve => scene(add(point, ve))[0]
        return norm([
          de([e, 0, 0]) - de([-e, 0, 0]),
          de([0, e, 0]) - de([0, -e, 0]),
          de([0, 0, e]) - de([0, 0, -e])
        ])
      }
    }

    class Canvas {

      constructor(factor = 1) {
        const element = document.getElementById("myCanvas")
        this.ctx = element.getContext("2d")

        this.size = [element.width, element.height]
        this.resolution = mul(this.size, 1 / factor)
      }

      paint(x, y, color) {
        const [cw, ch] = [0, 1].map(i => this.size[i] / this.resolution[i])
        const [r, g, b] = mul(color, 255).map(Math.round)
        this.ctx.fillStyle = `rgb(${r} ${g} ${b})`
        this.ctx.fillRect(x * cw, y * ch, cw, ch)
      }
    }

    async function render(camera) {
      for (const prog of [20, 10, 5, 2, 1])
        await camera.render(scene, new Canvas(prog))
    }

    render(new Camera())

    /////// Math ////////

    function norm(v) {
      const l = len(v)
      return v.map(n => n / l)
    }

    function len(v) {
      return Math.sqrt(sum(v.map(n => n * n)))
    }

    function add(...vs) {
      return vs[0].map((_, i) => sum(vs.map(a => a[i])))
    }

    function sum(v) {
      return v.reduce((a, c) => a + c, 0)
    }

    function mul(v, f) {
      return v.map(n => n * f)
    }

    function neg(v) {
      return mul(v, -1)
    }

    function dot(a, b) {
      return sum(a.map((_, i) => a[i] * b[i]))
    }

    function rot3(u, r) {
      const [x, y, z] = norm(u)
      const c = Math.cos(r)
      const s = Math.sin(r)
      const ci = 1 - c

      return [
        [x * x * ci + c, x * y * ci - z * s, x * z * ci + y * s],
        [x * y * ci + z * s, y * y * ci + c, y * z * ci - x * s],
        [x * z * ci - y * s, y * z * ci + x * s, z * z * ci + c]
      ]
    }

    function mmul(m, v) {
      return m.map(j => dot(j, v))
    }

    function mix(colors, ratios = null) {
      ratios ||= colors.map(() => 1)

      const rs = sum(ratios)
      return colors[0].map((_, i) =>
        Math.sqrt(sum(colors.map((c, n) =>
          c[i] * c[i] * ratios[n] / rs))))
    }

    function clamp(v, l, h) {
      return Math.min(Math.max(v, l), h)
    }

    function fade(l, h, t) {
      return l + (h - l) * t
    }

  </script>

</body>

</html>
