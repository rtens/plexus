<!DOCTYPE html>
<html>

<body style="background-color: #111">

  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>

  <canvas id="myCanvas" width="800" height="600">
    Sorry, your browser does not support canvas.
  </canvas>

  <script>

    ////// Shapes ////////
    const sphere = p => len(p) - 1

    const box = b => p => {
      const q = add(p.map(Math.abs), neg(b))
      return len(q.map(n => Math.max(n, 0))) + Math.min(Math.max(...q, 0), 0);
    }

    const torus = ([tx, ty]) => ([x, y, z]) => {
      const q = [len([x, z]) - tx, y]
      return len(q) - ty
    }

    ////// Materials ////////
    const cyan = () => [0, 1, 1, 0, 0]
    const magenta = () => [1, 0, 1, 0, 0]
    const yellow = () => [1, 1, 0, 0, 0]
    const red = () => [1, 0, 0, 0, 0]
    const green = () => [0, 1, 0, 0, 0]
    const blue = () => [0, 0, 1, 0, 0]
    const transp = (t, m) => p => (([r, g, b, _, s]) => [r, g, b, t, s])(m(p))
    const refl = (s, m) => p => (([r, g, b, t, _]) => [r, g, b, t, s])(m(p))

    ////// Construction ////////
    const obj = (sdf, mat) => p => [sdf(p), mat(p)]

    const union = (...objs) => p =>
      objs.reduce((a, c) => !a || c(p)[0] < a[0] ? c(p) : a, null)

    const sunion = (k, o1, o2) => p => {
      const [d1, m1] = o1(p)
      const [d2, m2] = o2(p)
      const h = clamp(.5 + .5 * (d2 - d1) / k, 0, 1)
      return [
        fade(d2, d1, h) - k * h * (1 - h),
        mix2(m1, m2, h)
      ]
    }

    const move = v => f => p => f(add(p, neg(v)))

    const rot = (u, r) => f => p => f(mmul(rot3(u, r), p))

    const scale = s => f => p => (([d, m]) => [d * s, m])(f(mul(p, 1 / s)))

    const round = r => f => p => (([d, m]) => [d - r, m])(f(p))

    const $ = (i, ...p) => p.reduce((a, c) => c(a), i)

    ////// Rendering ////////
    let scene = sunion(.1,
      sunion(.3,
        $(obj(box([1, .6, .7]), transp(.5, magenta)),
          round(.3),
          rot([1, 1, 0], .8),
          move([-.5, -.5, -6])),
        $(obj(sphere, cyan),
          scale(1.2),
          move([.3, .8, -6]))),
      $(obj(torus([1.2, .3]), refl(.3, yellow)),
        rot([1, 0, 0], -.5),
        move([0.5, -.5, -6])))

    class Camera {
      constructor(pos, rot, focal) {
        this.pos = pos || [0, 0, 0]
        this.rot = rot || rot3([1, 0, 0], 0)
        this.focal = focal || 1
        this.maxdist = 100
        this.dimming = .8
        this.res = .001
        this.bg = [0, 0, 0, 0, 0]
      }

      stop() {
        this.stopped = true
      }

      async render(scene, canvas) {
        const [rx, ry] = canvas.resolution

        const chunk = 1000
        for (let i = 0; !this.stopped && i < rx * ry; i += chunk) {
          const c = i
          await new Promise(resolve => setTimeout(() => {
            for (let j = c; !this.stopped && j < c + chunk; j++) {
              const x = j % rx
              const y = Math.floor(j / rx)

              const colors = this.rays(x, y, rx, ry)
                .map(ray => this.fragment(scene, ray, this.pos))
              canvas.paint(x, y, mix(colors))
              resolve()
            }
          }))
        }
      }

      rays(x, y, rx, ry) {
        const subs = [[.87, .5], [-.87, .5], [0, -1]]
        return subs.map(([dx, dy]) => mmul(this.rot, norm([
          + ((x + .5 + dx / 4) / rx - .5),
          - ((y + .5 + dy / 4) / ry - .5) * (ry / rx),
          -this.focal
        ])))
      }

      fragment(scene, ray, point, dist = 0) {
        let [m, p, d, n] = this.march(scene, ray, point, dist)

        if (!m) return this.bg

        if (m[4]) {
          const refl = this.reflect(scene, ray, p, d, n)
          m = mix2(refl, m, m[4])
        }

        return this.shade(scene, m, n, ray)
      }

      march(scene, ray, origin, dist) {
        let point = origin
        while (dist < this.maxdist) {
          const [d, m] = scene(point)

          if (d < this.res * dist) {
            const n = this.normal(scene, point)
            return [m, point, dist, n]
          }

          dist += d
          point = add(point, mul(ray, d))
        }

        return []
      }

      shade(scene, m, n, ray) {
        const f = (dot(ray, neg(n)) - 1) * this.dimming + 1
        return mix2(m, this.bg, f)
      }

      normal(scene, point) {
        const e = this.res / 10
        const de = ve => scene(add(point, ve))[0]
        return norm([
          de([e, 0, 0]) - de([-e, 0, 0]),
          de([0, e, 0]) - de([0, -e, 0]),
          de([0, 0, e]) - de([0, 0, -e])
        ])
      }

      reflect(scene, ray, p, d, n) {
        const reflr = add(ray, neg(mul(n, 2 * dot(ray, n))))
        const reflp = add(p, mul(n, this.res * 2 * d))
        return this.fragment(scene, reflr, reflp, d)
      }
    }

    class Canvas {

      constructor(factor = 1) {
        const element = document.getElementById("myCanvas")
        this.ctx = element.getContext("2d")

        this.size = [element.width, element.height]
        this.resolution = mul(this.size, 1 / factor)
      }

      paint(x, y, color) {
        const [cw, ch] = [0, 1].map(i => this.size[i] / this.resolution[i])
        const [r, g, b] = mul(color, 255).map(Math.round)
        this.ctx.fillStyle = `rgb(${r} ${g} ${b})`
        this.ctx.fillRect(x * cw, y * ch, cw, ch)
      }
    }

    let camera = new Camera()

    async function render() {
      for (const prog of [20, 10, 5, 2, 1])
        await camera.render(scene, new Canvas(prog))
    }

    render()

    ////// Control ///////
    const cam = {
      pos: [0, 0, 0],
      focal: 1
    }

    const actions = {
      d: () => cam.pos[0] = cam.pos[0] + .1,
      a: () => cam.pos[0] = cam.pos[0] - .1,
      w: () => cam.pos[1] = cam.pos[1] + .1,
      s: () => cam.pos[1] = cam.pos[1] - .1,
      q: () => cam.pos[2] = cam.pos[2] + .1,
      e: () => cam.pos[2] = cam.pos[2] - .1,
      r: () => cam.focal *= 1.1,
      f: () => cam.focal /= 1.1,
    }

    document.onkeydown = ({ key }) => {
      if (!(key in actions)) return

      camera.stop()
      actions[key]()
      camera = new Camera(cam.pos, null, cam.focal)
      render()
    }

    /////// Math ////////

    function norm(v) {
      const l = len(v)
      return v.map(n => n / l)
    }

    function len(v) {
      return Math.sqrt(sum(v.map(n => n * n)))
    }

    function add(...vs) {
      return vs[0].map((_, i) => sum(vs.map(a => a[i])))
    }

    function sum(v) {
      return v.reduce((a, c) => a + c, 0)
    }

    function mul(v, f) {
      return v.map(n => n * f)
    }

    function neg(v) {
      return mul(v, -1)
    }

    function dot(a, b) {
      return sum(a.map((_, i) => a[i] * b[i]))
    }

    function rot3(u, r) {
      const [x, y, z] = norm(u)
      const c = Math.cos(r)
      const s = Math.sin(r)
      const ci = 1 - c

      return [
        [x * x * ci + c, x * y * ci - z * s, x * z * ci + y * s],
        [x * y * ci + z * s, y * y * ci + c, y * z * ci - x * s],
        [x * z * ci - y * s, y * z * ci + x * s, z * z * ci + c]
      ]
    }

    function mmul(m, v) {
      return m.map(j => dot(j, v))
    }

    function mix(colors, ratios = null) {
      ratios ||= colors.map(() => 1)

      const rs = sum(ratios)
      return colors[0].map((_, i) =>
        Math.sqrt(sum(colors.map((c, n) =>
          c[i] * c[i] * ratios[n] / rs))))
    }

    function mix2(a, b, r) {
      return mix([a, b], [r, 1 - r])
    }

    function clamp(v, l, h) {
      return Math.min(Math.max(v, l), h)
    }

    function fade(l, h, t) {
      return l + (h - l) * t
    }

  </script>

</body>

</html>
