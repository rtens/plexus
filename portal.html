<!DOCTYPE html>
<html>

<body style="background-color: #111">

  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>

  <canvas id="myCanvas" width="800" height="600">
    Sorry, your browser does not support canvas.
  </canvas>

  <script>

    ////// Shapes ////////
    const sphere = p => len(p) - 1

    const box = b => p => {
      const q = add(p.map(Math.abs), neg(b))
      return len(q.map(n => Math.max(n, 0))) + Math.min(Math.max(...q, 0), 0);
    }

    const torus = ([tx, ty]) => ([x, y, z]) => {
      const q = [len([x, z]) - tx, y]
      return len(q) - ty
    }

    ////// Materials ////////
    const cyan = () => [0, 1, 1]
    const magenta = () => [1, 0, 1]
    const yellow = () => [1, 1, 0]

    ////// Construction ////////
    const obj = (sdf, mat) => p => [sdf(p), mat(p)]

    const union = objs => p =>
      objs.reduce((a, c) => !a || c(p)[0] < a[0] ? c(p) : a, null)

    const move = v => f => p => f(add(p, neg(v)))

    const rot = (u, r) => f => p => f(mmul(rot3(u, r), p))

    const scale = s => f => p => (([d, m]) => [d * s, m])(f(mul(p, 1 / s)))

    const $ = (i, ...p) => p.reduce((a, c) => c(a), i)

    ////// Rendering ////////
    const scene = union([
      $(obj(box([1.1, .8, 1]), magenta), rot([1, 1, 0], .8), move([-.5, -.5, -6])),
      $(obj(sphere, cyan), scale(1.2), move([.3, .8, -6])),
      $(obj(torus([1, .4]), yellow), rot([1, 0, 0], -.5), move([0.5, -.5, -6]))
    ])

    class Camera {
      constructor() {
        this.focal = 1
        this.maxdist = 100
        this.dimming = .7
      }

      async render(scene, canvas) {
        const [rx, ry] = canvas.resolution

        const chunk = 1000
        for (let i = 0; i < rx * ry; i += chunk) {
          const c = i
          await new Promise(resolve => setTimeout(() => {
            for (let j = c; j < c + chunk; j++) {
              const x = j % rx
              const y = Math.floor(j / rx)

              const colors = []
              for (const [dx, dy] of [[.87, .5], [-.87, .5], [0, -1]]) {
                const ray = norm([
                  + ((x + .5 + dx / 4) / rx - .5),
                  - ((y + .5 + dy / 4) / ry - .5) * (ry / rx),
                  -this.focal
                ])
                colors.push(this.fragment(scene, ray))
              }

              canvas.paint(x, y, mix(colors))

              resolve()
            }
          }))
        }
      }

      fragment(scene, ray) {
        let point = [0, 0, 0]
        let dist = 0

        while (dist < this.maxdist) {
          const [d, m] = scene(point)

          if (d < 0.001) {
            return this.shade(scene, m, point, ray)
          }

          dist += d
          point = add(point, mul(ray, d))
        }

        return [0, 0, 0]
      }

      shade(scene, m, point, ray) {
        const n = this.normal(scene, point)
        const f = (dot(ray, neg(n)) - 1) * this.dimming + 1
        return mul(m, f)
      }

      normal(scene, point) {
        const e = 0.0001
        const de = ve => scene(add(point, ve))[0]
        return norm([
          de([e, 0, 0]) - de([-e, 0, 0]),
          de([0, e, 0]) - de([0, -e, 0]),
          de([0, 0, e]) - de([0, 0, -e])
        ])
      }
    }

    class Canvas {

      constructor(factor = 1) {
        const element = document.getElementById("myCanvas")
        this.ctx = element.getContext("2d")

        this.size = [element.width, element.height]
        this.resolution = mul(this.size, 1 / factor)
      }

      paint(x, y, color) {
        const [cw, ch] = [0, 1].map(i => this.size[i] / this.resolution[i])
        const [r, g, b] = mul(color, 255).map(Math.round)
        this.ctx.fillStyle = `rgb(${r} ${g} ${b})`
        this.ctx.fillRect(x * cw, y * ch, cw, ch)
      }
    }

    async function render(camera) {
      for (const prog of [20, 10, 5, 2, 1])
        await camera.render(scene, new Canvas(prog))
    }

    render(new Camera())

    /////// Math ////////

    function norm(v) {
      const l = len(v)
      return v.map(n => n / l)
    }

    function len(v) {
      return Math.sqrt(sum(v.map(n => n * n)))
    }

    function add(...v) {
      return v[0].map((_, i) => sum(v.map(a => a[i])))
    }

    function sum(v) {
      return v.reduce((a, c) => a + c, 0)
    }

    function mul(v, f) {
      return v.map(n => n * f)
    }

    function neg(v) {
      return mul(v, -1)
    }

    function dot(a, b) {
      return sum(a.map((_, i) => a[i] * b[i]))
    }

    function rot3(u, r) {
      const [x, y, z] = norm(u)
      const c = Math.cos(r)
      const s = Math.sin(r)
      const ci = 1 - c

      return [
        [x * x * ci + c, x * y * ci - z * s, x * z * ci + y * s],
        [x * y * ci + z * s, y * y * ci + c, y * z * ci - x * s],
        [x * z * ci - y * s, y * z * ci + x * s, z * z * ci + c]
      ]
    }

    function mmul(m, v) {
      return m.map(j => dot(j, v))
    }

    function mix(colors) {
      const f = 1 / colors.length
      return colors[0].map((_, i) =>
        Math.sqrt(colors.reduce((a, c) => a + c[i] * c[i] * f, 0)))
    }

  </script>

</body>

</html>
